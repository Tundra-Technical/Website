<?php
// Load include file
module_load_include('inc','bullhorn_job_board');

/**
 * Implementation of hook_menu()
 * @return mixed
 */

function bullhorn_job_board_menu() {

    $items = array();

    $items['admin/config/content/bullhorn/bullhorn_get_subscribed_events'] = array(
        'title'            => 'Get Subscribed Events (Runs in Cron)',
        'description'      => 'Get subscribed events from Bullhorn.',
        'page callback'    => 'bullhorn_job_board_subscribed_events',
        'access arguments' => array('access administration pages'),
        'weight'           => 2,
        'type'             => MENU_NORMAL_ITEM,
    );

    $items['admin/config/content/bullhorn/get_subscribed_events_by_request_id'] = array(
        'title'            => 'Get Subscribed Events by last request ID',
        'description'      => 'Get subscribed events from Bullhorn using the last request id.',
        'page callback'    => 'bullhorn_job_board_subscribed_events_request_by_id',
        'access arguments' => array('access administration pages'),
        'weight'           => 3,
        'type'             => MENU_NORMAL_ITEM,
    );

    $items['admin/config/content/bullhorn/%/get_subscribed_events_by_request_id'] = array(
        'title'            => 'Get Subscribed Events by wildcard value',
        'description'      => 'Get subscribed events from Bullhorn using a numeric wildcard value in menu path.',
        'page callback'    => 'bullhorn_job_board_subscribed_events_request_by_id',
        'page arguments'   => array( 4 ),
        'access arguments' => array('access administration pages'),
        'type'             => MENU_CALLBACK,
    );

    $items['admin/config/content/bullhorn/bullhorn_event_subscribe'] = array(
        'title'            => 'Subscribe to events',
        'description'      => 'Subscribe to Bullhorn Events INSERTED, UPDATED and DELETED',
        'page callback'    => 'bullhorn_job_board_events_subscribe',
        'access arguments' => array('access administration pages'),
        'weight'           => 4,
        'type'             => MENU_NORMAL_ITEM,
    );

    $items['admin/config/content/bullhorn/bullhorn_get_jobs'] = array(
        'title'            => 'Get all Jobs (Deprecated)',
        'description'      => 'Get Jobs from Bullhorn',
        'page callback'    => 'bullhorn_job_board_get_jobs',
        'access arguments' => array('access administration pages'),
        'weight'           => 5,
        'type'             => MENU_NORMAL_ITEM,
    );

    return $items;
}

/**
 * Bullhorn Job Board Query
 *
 * @param $BhRestToken
 * @param $BhURL
 * @return mixed
 */

function bullhorn_job_board_query( $BhRestToken, $BhURL ) {
    $raw_result = db_query("SELECT max(field_job_order_id_value) as val FROM field_data_field_job_order_id");

    $item = $raw_result->fetchObject();

    //$data = "query/JobOrder?fields=id,address,dateAdded,employmentType,skillList,publicDescription,title,dateEnd,categories&where=id>".$item->val."&orderBy=+id&BhRestToken=".$BhRestToken;
    //$data = "query/JobOrder?fields=title,id,address,dateAdded,employmentType,skillList,dateEnd,dateEnd,categories,status,publishedZip,isPublic&where=id".$item->val."%20AND%20isPublic=1&orderBy=-id&count=20&BhRestToken=".$BhRestToken;
//    $data = "query/JobOrder?fields=title,id,address,dateAdded,employmentType,skillList,dateEnd,categories,status,publishedZip,isPublic,publicDescription&where=id>" . $item->val . "%20AND%20isPublic=1&orderBy=-id&count=20&BhRestToken=" . $BhRestToken;

    $data = "query/JobOrder?fields=title,id,address,dateAdded,employmentType,skillList,dateEnd,categories,status,publishedZip,isPublic,publicDescription,payRate&where=isPublic=1&orderBy=-id&count=20&BhRestToken=" . $BhRestToken;

    $tuCurl = curl_init();
    curl_setopt($tuCurl, CURLOPT_URL, $BhURL . $data);
    curl_setopt($tuCurl, CURLOPT_PORT, 443);
    curl_setopt($tuCurl, CURLOPT_VERBOSE, 0);
    curl_setopt($tuCurl, CURLOPT_HEADER, 0);
    curl_setopt($tuCurl, CURLOPT_SSLVERSION, 3);
    curl_setopt($tuCurl, CURLOPT_SSL_VERIFYPEER, 1);
    curl_setopt($tuCurl, CURLOPT_RETURNTRANSFER, 1);
    $tuData = curl_exec($tuCurl);
    curl_close($tuCurl);

    return $tuData;
}

/**
 * Bullhorn Job Board Events Subscribe
 */

function bullhorn_job_board_events_subscribe () {

    $subscription_id = variable_get('bullhorn_rest_api_subscription_id');

    $session_obj = bullhorn_rest_api_login();

    $uri = 'event/subscription/' . $subscription_id . '?type=entity&names=JobOrder&eventTypes=INSERTED,UPDATED,DELETED';
    $url = $session_obj->restUrl . $uri;

    $query = http_build_query(
        array(
            'BhRestToken' => $session_obj->BhRestToken,
        )
    );

    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, $url);
    curl_setopt($ch, CURLOPT_PORT, 443);
    curl_setopt($ch, CURLOPT_VERBOSE, 0);
    curl_setopt($ch, CURLOPT_HEADER, 0);
    curl_setopt($ch, CURLOPT_SSLVERSION, 3);
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 1);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "PUT");
    curl_setopt($ch, CURLOPT_POSTFIELDS, $query);
    curl_setopt($ch, CURLOPT_HTTPHEADER, array('BhRestToken:' . $session_obj->BhRestToken)); //After much searching, trial and error this was the key
    $result = curl_exec($ch);

    if($result === false) {
        $ch_errno = curl_errno($ch);
        $ch_error = curl_error($ch);
        watchdog( 'bullhorn job board', 'cURL request failed. Error No.: ( %errno ), Error: ( %error )', array( '%errno' => $ch_errno, '%error' => $ch_error ), WATCHDOG_DEBUG );
    }

    curl_close($ch);

    $response = json_decode($result);

}

/**
 * Bullhorn Job Board Subscribed Events Request By ID
 *
 * @param int $request_id
 * @return string
 */

function bullhorn_job_board_subscribed_events_request_by_id( $request_id = 0 ) {

    // Log in to Bullhorn REST API
    $session_obj = bullhorn_rest_api_login();

    // Get last request id if $request_id is false
    if( !$request_id || !is_numeric( $request_id ) ) {
        $bullhorn_event_request_id = variable_get( 'bullhorn_event_request_id' );
    } else {
        $bullhorn_event_request_id = $request_id;
    }

    $response = job_board_get_subscribed_events( $session_obj, $bullhorn_event_request_id );

    if( empty($response) ) {
        watchdog( 'bullhorn job board', 'Ran subscribed events fore request id ( %id )and result was empty.', array( '%id' => $bullhorn_event_request_id ), WATCHDOG_INFO );
        exit;
    }

//    dpm( $response );

    // Get the events from the
    // Response
    $events = $response->events;

    // Set and Array
    // to collect all
    // event inserts
    $inserts = array();

    // Set an Array
    // to collect all
    // event updates
    $updates = array();

    // Set an Array
    // to collect all
    // event updates
    $deletes = array();

    // Get INSERTED events
    $inserted = job_board_sort_events_by_event_type( $events, 'inserted' );

    // If $inserted Array is not empty then process INSERTED Events
    $insert_result = bullhorn_job_board_get_inserts( $inserted, $inserts, $session_obj );

    // Get UPDATED events
    $updated = job_board_sort_events_by_event_type( $events, 'updated' );

    // If $update Array is not empty then process UPDATED Events
    $update_result = bullhorn_job_board_get_updates( $updated, $updates, $inserts, $session_obj );

    // Get DELETED events
    $deleted = job_board_sort_events_by_event_type( $events, 'deleted' );

//    dpm( $inserted, 'inserted' );
//    dpm( $inserts, 'inserts' );
//    dpm( $updated, 'updated' );
//    dpm( $updates, 'updates' );
//    dpm( $deleted, 'deleted' );
//    dpm( $deletes, 'deletes' );

    // If $delete Array is not empty then process DELETED Events
    $delete_result = bullhorn_job_board_get_deletes( $deleted, $deletes );

    // Save all the found INSERTED JobOrder
    // Events
    if( !empty( $inserts ) ) {
        bullhorn_job_board_insert( $inserts );
    }

    // Update all the found UPDATED JobOrder
    // Events
    if( !empty( $updates ) ) {
        bullhorn_job_board_update( $updates );
    }

    // Delete all the found DELETED JobOrder
    // Events and any unused taxonomy terms
    if( !empty( $deletes ) ) {
        bullhorn_job_board_delete( $deletes );
    }

    // Print dpm or debug result to the screen
    return '';
}

/**
 * Bullhorn Job Board Subscribed Events
 */

function bullhorn_job_board_subscribed_events() {

    // Log in to the Bullhorn REST API

    $session_obj = bullhorn_rest_api_login();

    // Get the subscribed events from Bullhorn

    $response = job_board_get_subscribed_events( $session_obj );

    if( empty($response) ) {
        watchdog( 'bullhorn job board', 'Ran subscribed events and result was empty.', array(), WATCHDOG_INFO );
        exit;
    }

    // Set the current requestId for this event i.e. to
    // recover from a failure to perform this request the
    // first time
    $request_id = $response->requestId;
    variable_set( 'bullhorn_event_request_id', $request_id ); // Let's save it in the variables table for now and save ourselves a request

    // Test response for debugging
//    $response = job_board_test_events();

    // Set the events Array
    $events = $response->events;

    // Set and Array
    // to collect all
    // event inserts
    $inserts = array();

    // Set an Array
    // to collect all
    // event updates
    $updates = array();

    // Set an Array
    // to collect all
    // event deletes
    $deletes = array();

    // Get INSERTED events
    $inserted = job_board_sort_events_by_event_type( $events, 'inserted' );

    // If $inserted Array is not empty then process INSERTED Events
    $insert_result = bullhorn_job_board_get_inserts( $inserted, $inserts, $session_obj );

    // Get UPDATED events
    $updated = job_board_sort_events_by_event_type( $events, 'updated' );

    // If $update Array is not empty then process UPDATED Events
    $update_result = bullhorn_job_board_get_updates( $updated, $updates, $inserts, $session_obj );

    // Get DELETED events
    $deleted = job_board_sort_events_by_event_type( $events, 'deleted' );

    // If $delete Array is not empty then process DELETED Events
    $delete_result = bullhorn_job_board_get_deletes( $deleted, $deletes );

    // Save all the found INSERTED JobOrder
    // Events
    if( !empty( $inserts ) ) {
        bullhorn_job_board_insert( $inserts );
    }

    // Update all the found UPDATED JobOrder
    // Events
    if( !empty( $updates ) ) {
        bullhorn_job_board_update( $updates );
    }

    // Delete all the found DELETED JobOrder
    // Events and any unused taxonomy terms
    if( !empty( $deletes ) ) {
        bullhorn_job_board_delete( $deletes );
    }

    // Print dpm or debug result to the screen
    return '';
}

/**
 * Bullhorn Job Board Insert
 *
 * Take INSERTED entityEventType(s) and reduce them to events that pass
 * the REST request condition isPublic=1, to an Array of $inserts to be
 * added to the system as job_order nodes.
 *
 * Since not every INSERTED JobOrder event will get isPublic=1 they
 * they will not all get saved as job_order nodes. Instead defer saving
 * these JobOrder(s) till later when isPublic is updated to '1'. This
 * sounds counter intuitive however it's the only way to avoid creating
 * 100s of nodes for which the isPublic property might never get set to
 * '1' or even change at all.
 *
 * @param $inserted
 * @param $inserts
 * @param $session
 * @return bool|string
 */

function bullhorn_job_board_get_inserts( $inserted, &$inserts, $session ) {

    // If there are no $inserted
    // events then end execution
    if( empty( $inserted ) ) {
        return true;
    }

    // Set the entityIds
    $entity_ids = array();

    // Loop through all the $inserted
    // JobOrders and get the entityId(s)
    // for those that are not already
    // in the system as values for the
    // field_job_order_id of the
    // job_order bundle
    foreach( $inserted as $insert ) {

        // If the $insert->entityId is set, not empty and does not already exist as a field_job_order_id attached to a node in the system then add it to the list
        if( isset( $insert->entityId ) && !empty( $insert->entityId ) && ( !$entity = job_board_count_node_by_job_order_id( $insert->entityId ) ) ) {

            $entity_ids[] = $insert->entityId;

        }
    }

    // If $entity_ids is empty
    // then end the execution
    if( empty( $entity_ids ) ) {

        watchdog( 'bullhorn job board', 'Found INSERTED event and either there was/were no entityId(s) or there was/were node(s) with matching job_order_id(s)', array(), WATCHDOG_NOTICE );
        return false;

    }

    // Split the $entity_ids Array in to chunks of 15
    $entity_id_chunks = array_chunk( $entity_ids, 15 );

    // Loop through the chunks of $entity_ids
    // and request 15 at a time
    foreach( $entity_id_chunks as $ids ) {

        // Implode $ids into comma separated string
        $ids_in = implode( ',', $ids );

        // Trim the last comma
        $ids_in = trim( $ids_in, ',' );

        // Build a REST request to retrieve data for the inserted JobOrder
        $bh_rest_token = $session->BhRestToken;
        $fields = job_board_job_order_fields_clause();
        $uri = 'query/JobOrder?fields=' . $fields . ',status&where=id%20IN%20(' . $ids_in . ')%20AND%20isPublic=1&BhRestToken=' . $bh_rest_token;
        $url = $session->restUrl . $uri;

        // Do the REST request
        $_response = bullhorn_rest_api_get_request( $url );

        // If the $_response was empty OR the $_response->count returned zero results
        // continue to the next chunk of INSERTED entityIds
        if( empty( $_response ) || ( isset( $_response->count ) && !$_response->count ) ) {

            watchdog( 'bullhorn job board', 'Found INSERTED events and a REST request for entityIds ( %ids ) returned no results.', array( '%ids' => $ids_in ), WATCHDOG_DEBUG );
            continue;

        }

        foreach( $_response->data as $data ) {
            $inserts[] = $data;
        }
    }

    // Print dpm or debug result to the screen
    return '';
}

/**
 * Bullhorn Job Board Update
 *
 * Take UPDATED entityEventType(s), separate and reduce them to two Arrays,
 * $updates and $inserts.
 *
 * Since UPDATED events can make previously INSERTED events ready for publishing
 * to the website, separate UPDATED events with an updatedProperty of isPublic
 * after it returns as a result from the REST request which must pass the
 * 'where' condition isPublic=1. UPDATED events that meet this condition will be
 * add to the $inserts Array instead.
 *
 * Only update nodes for which the updatedProperty is one which is captured as
 * a field on the job_order bundle and exists as a node in the system, associated
 * by entityId = field_job_order_id, should be added to the $updates Array.
 *
 * @param $updated
 * @param $updates
 * @param $inserts
 * @param $session
 * @return bool|string
 */

function bullhorn_job_board_get_updates( $updated, &$updates, &$inserts, $session ) {

    // If there are no $updated
    // events then end execution
    if( empty( $updated ) ) {
        return true;
    }

    // Start by reducing the $updated events to those that
    // have properties that we use on the job_order bundle

    // Get an associative Array of JobOrder Entity/job_order bundle fields that we use
    $entity_job_order_fields = job_board_entity_job_order_fields_association();

    $_updates = array();

    // Loop through the $updated
    // events
    foreach( $updated as $update) {

        // Find the entityId in the field_data_field_job_order_id table
//        $node = job_board_get_node_by_job_order_id( $update->entityId );

        // If an $entity (type:
        // node) does not exist
        // locally then continue
        // to the next $update
//        if( empty( $node ) ) {
//            continue;
//        }

        // Loop through the updatedProperties and find only those
        // properties that we use for the job_order bundle
        foreach( $update->updatedProperties as $updated_property) {

            // if the $updated_property is a field on our job_order bundle then
            // create and $updates element for the entity keyed by the JobOrder
            // entityId, set a sub Array of updated_properties if it doesn't already
            // exist and add the property
            if( array_key_exists( $updated_property, $entity_job_order_fields ) ) {

                // Reduce duplicates

                if( isset( $_updates[$update->entityId]['updated_properties'] ) && in_array( $updated_property, $_updates[$update->entityId]['updated_properties'] ) ) {
                    continue;
                }

                $_updates[$update->entityId]['updated_properties'][] = $updated_property;
            }
        }
    }

    // If none of the updatedProperties are on the list of $entity_job_order_fields then end execution
    if( empty( $_updates ) ) {
        watchdog( 'bullhorn job board', 'Found UPDATED event and no applicable job_order fields were found.', array(), WATCHDOG_NOTICE );
        return false;
    }

    // Set an Array of $entity_ids by
    // getting the keys of the $updates
    // Array
    $entity_ids = array_keys( $_updates );

    // Split the $entity_ids into chunks of 15
    $entity_id_chunks = array_chunk( $entity_ids, '15' );

    // Loop through each chunk of ids, query Bullhorn
    // for data, separate the updates that should be
    // inserted and eliminate any $updated events added
    // to the $updates Array that don't have and entityId
    // added to the field_job_order_id of the job_order
    // bundle
    foreach( $entity_id_chunks as $id_chunk ) {

        // Set an comma separated list of the entityId(s)
        // for use in REST request
        $entity_ids_str = implode( $id_chunk, ',' );
        $entity_ids_str = trim ( $entity_ids_str, ',' );

        // Build a REST request path to retrieve data for the updated JobOrder(s) by id
        $bh_rest_token = $session->BhRestToken;
        $fields = job_board_job_order_fields_clause();
        $uri = 'query/JobOrder?fields='. $fields .',status&where=id%20IN%20(' . $entity_ids_str . ')%20AND%20isPublic=1&BhRestToken=' . $bh_rest_token;
        $url = $session->restUrl . $uri;

        // Do the REST request
        $updated_response = bullhorn_rest_api_get_request( $url );

        // If $response is empty then end execution
        if( empty( $updated_response ) || ( isset( $updated_response->count ) && !$updated_response->count) ) {

            // Unset the $updates for
            // entityId(s) requested in
            // this chunk
            foreach( $id_chunk as $id ) {
                unset( $_updates[$id] );
            }

            watchdog( 'bullhorn job board', 'Found UPDATED event and REST request returned no results.', array(), WATCHDOG_DEBUG );
            return false;
        }

        // Get the data array
        $updated_data = $updated_response->data;

        // Loop through the $updated_data and
        // separate $updated_data and should be
        // $inserts i.e. the job_order node
        // does not exists in the systems but the
        // isPublic property of the JobOrder entity
        // has updated and therefore data was
        // retrieved via the REST request, from
        // those that do have a node in the system
        // and should be $updates
        foreach( $updated_data as $update_data ) {

            // If isPublic is one one of the updatedProperties then we assume that this is
            // a JobOrder ready to be published to the website
            $insert = false;
            if( in_array( 'isPublic', $_updates[$update_data->id]['updated_properties'] ) ) {
                $insert = true;
            }

            // Get the $node from the field_data_field_job_order_id table for the
            // current $updates_data
            $node = job_board_get_node_by_job_order_id( $update_data->id );

//            dpm( $node, 'node' );
//            dpm( $insert, 'insert' );

            // If the JobOrder is an insert
            // because its isPublic property
            // has changed then the update
            // represents a JobOrder that is
            // ready to be published to the
            // website. Add the update
            // to the $inserts Array and
            // continue to the next loop
            // iteration
            if( empty( $node ) && $insert ){

                // This update signals an
                // JobOrder that has changed
                // 'public' status and must
                // be inserted into the system
                // therefore add it to the
                // $inserts list
                $inserts[] = $update_data;

                // As a result of the above condition
                // there is no node in the system
                // to update yet. Therefore remove
                // it from the $updates list
                unset( $_updates[$update_data->id] );

                continue;
            }

            // If the JobOrder is not an insert because its isPublic property
            // has changed and the id represents a field in the
            // field_data_field_job_order_id table then associate $updated_data
            // with the $updates
            if( !empty( $node ) ) {
//                foreach( $updates as $entity_id => $update ) {
//                    if( $update_data->id == $entity_id ) {
                        debug( $update_data->id . ' added.' );
                        $updates[$update_data->id]['updated_properties'] = $_updates[$updated_data->id]['updated_properties'];
                        $updates[$update_data->id]['updated_data']       = $update_data;
                        $updates[$update_data->id]['node']               = $node;
//                    }
//                }
            }
        }

        // Remove entities from the $updates Array that
        // are not part of the update response because
        // they do not meet the request conditions

//        dpm( $id_chunk, 'id_chunk' );
        // Loop through the $id_chunk
        /*foreach( $id_chunk as $id ) {

            dpm( $id, 'id' );

            // Set a flag to
            // determine if
            // the $id is found
            $found_id = false;

            // Loop through the $updates received
            // as a response to this chunk of $updates
            // and find the $id
            dpm( $updated_data );
//            foreach( $updated_data as $update_data ) {
            foreach( $updates as $update_data ){

                dpm( $update_data, 'update data' );
                // If the $id is found in the
                // $updated_data then return true
//                if( $id == $update_data->id ) {
                if( $id == array_keys( $update_data ) ) {
                    debug( $id . ' found' );
                    $found_id = true;
                }
            }

            // If after looping through
            // the $updated_data the $id
            // was not found then unset it
            // in the $updates Array
            if( !$found_id ) {
                dpm( $updates, 'id not found' );
                unset( $updates[$id] );
            }
        }*/
    }

    // Print dpm or debug result to the screen
    return '';
}

/**
 * Bullhorn Job Board Delete
 *
 * Delete any job_order nodes in the system
 * that are found to have matching
 * field_job_order_id(s) to the DELETED
 * JobOrder entityId(s).
 *
 * Collect all the term references for the
 * deleted and nodes. After deleting the
 * nodes check to see if any term is attached
 * to any other job_order nodes and if not
 * delete it.
 *
 * @param $deleted
 * @param $deletes
 * @return bool
 */

function bullhorn_job_board_get_deletes( $deleted, &$deletes ) {

    // If there are no $deleted
    // events then end execution
    if( empty( $deleted ) ) {
        return true;
    }

    // Collect the $job_order_ids(
    // entityId(s)) for searching
    // and deleting nodes
    $job_order_ids = array();
    foreach( $deleted as $delete ) {
        $job_order_ids[] = $delete->entityId;
    }

    if( empty( $job_order_ids ) ) {
        watchdog( 'bullhorn job board', 'Found DELETED event with no entityId(s).', array(), WATCHDOG_DEBUG );
        return false;
    }

    // Get nid(s) for job_order nodes with field_job_order_id(s) in $deleted[$i]->entityId

    $query = new EntityFieldQuery();
    $query->entityCondition( 'entity_type', 'node' )
        ->entityCondition( 'bundle', 'job_order' )
        ->fieldCondition( 'field_job_order_id', 'value', $job_order_ids, 'IN' );
    $result = $query->execute();

    if( empty( $result ) ) {
        watchdog( 'bullhorn job board', 'Found DELETED event and failed to find job_order_id(s).', array(), WATCHDOG_DEBUG );
        return false;
    }

    $deletes['job_order_nids'] = array_keys( $result['node'] );

    // Load the nodes affected by the delete
    $nodes = node_load_multiple( $deletes['job_order_nids'] );

    // Get the taxonomy terms for each node
    $job_order_terms = array(
        'field_job_board_location' => array(),
        'field_country'            => array(),
        'field_city'               => array(),
        'field_employment_type'    => array(),
        'field_category'           => array(),
    );

    // Get the term ids for the each of the term reference
    // fields attached to all of the nodes being deleted
    foreach( $job_order_terms as $field_name => $terms ) {
        foreach( $nodes as $node ) {
            $deletes['job_order_terms'][$field_name][$node->nid] = field_get_items( 'node', $node, $field_name );
        }
    }

    /*$deletes = array(
        'job_order_nids' => $job_order_nids,
        'job_order_terms' => $job_order_terms,
    );*/
}

/**
 * Bullhorn Job Board Node Insert
 *
 * @param $data
 * @return bool
 */

function bullhorn_job_board_job_order_insert( $data ) {

    // Create a node Object
    $node = new stdClass();
    $node->type = 'job_order';
    node_object_prepare($node);

    // Set the node language
    $node->language = "en";

    // Set the node Title
    $node->title = ucfirst( strtolower( $data->title ) );

    // Attach the JobOrder ID for this node
    $node->field_job_order_id[LANGUAGE_NONE][0]['value'] = $data->id;

    // Attach the payRate
    $node->field_rate[LANGUAGE_NONE][0]['value'] = (float) $data->payRate;

    // Clean the body HTML
    $clean_html = job_board_clean_body_html( $data->publicDescription );
    // Attach the node Body, Summary and set the format
    $node->body[LANGUAGE_NONE][0]['value'] = $clean_html;
    $node->body[LANGUAGE_NONE][0]['summary'] = text_summary($clean_html);
    $node->body[LANGUAGE_NONE][0]['format'] = 'full_html';

    // Process and attach the Published date for this node
    $alter_time = $data->dateAdded / 1000;
    $post_date = date("Y-m-d", $alter_time);
    $post_date = $post_date . " 00:00:00";
    $node->field_published[LANGUAGE_NONE][0]['value'] = $post_date;

    // Process and attach the Expires data for this node
    $alter_time = $data->dateEnd / 1000;
    $post_date = date("Y-m-d", $alter_time);
    $post_date = $post_date . " 00:00:00";
    $node->field_expires[LANGUAGE_NONE][0]['value'] = $post_date;

    // Set the Category name
    // TODO query Bullhorn for the category name instead of hardcoding an Array of category_id to category_names
    // because new categories can be introduced
    $cat_name = job_board_category_id_to_name( $data->categories->data[0]->id );

    // Process the Category name and attach it to the node
    $field_category = job_board_process_taxonomy_term('categories',$cat_name);
    $node->field_category[LANGUAGE_NONE][0]['tid'] = $field_category;

    // Process and attach the Employment Type to the node
    $employment_type_term = ucwords(strtolower($data->employmentType));
    $field_employment_type = job_board_process_taxonomy_term('employment_types',$employment_type_term);
    $node->field_employment_type[LANGUAGE_NONE][0] = array( 'tid' => $field_employment_type );

    // Process the Country and City terms for this node. Associate the City with its applicable Country and attach
    // the City to the node. The View's exposed filter is set to a depth of 1 and will display all Cities for the
    // applicable Country when selected
    $country = job_board_process_country_id( $data->address->countryID );
    $field_job_board_location = array();
    $field_job_board_location[] = job_board_process_taxonomy_term( 'job_board_location', $country );
    $field_job_board_location[] = job_board_process_taxonomy_term( 'job_board_location', $data->address->city, $country );
    $node->field_job_board_location[LANGUAGE_NONE][0] = array( 'tid' => $field_job_board_location[1] );

    // Process and attach the City to the node
    $field_city = job_board_process_taxonomy_term( 'cities', ucwords( strtolower( $data->address->city ) ) );
    $node->field_city[LANGUAGE_NONE][0] = array( 'tid' => $field_city );

    // Process and attach the Country to the node
    $field_country = job_board_process_taxonomy_term( 'countries' , $country );
    $node->field_country[LANGUAGE_NONE][0] = array( 'tid' => $field_country );

    // Attach the Skill List to the node
    // TODO make the Skill List a vocabulary with an unlimited number of values
    $skill_list = ucfirst(strtolower($data->skillList));
    $skill_list = substr($skill_list, 0, 250);
    $node->field_skills[LANGUAGE_NONE][0]['value'] = $skill_list;

    // Set and attach the path to the node
//    $path = 'joborder/programmatically_created_node_' . date('YmdHis');
//    $node->path = array('alias' => $path);
    $node->path['pathauto'] = TRUE;
    $node->uid = 1;

    return $node;
}

/**
 * Bullhorn Job Board Job Order Update
 *
 * @param $node
 * @param $data
 * @param $property
 * @return mixed
 */

function bullhorn_job_board_job_order_update( $node, $data, $property ) {

    switch ( $property ) {
        case 'title':
            $node->title = ucfirst(strtolower($data->title));
            break;

        case 'publicDescription':
            $body = job_board_clean_body_html( $data->publicDescription );

            $node->body[LANGUAGE_NONE][0]['value'] = $body;
            $node->body[LANGUAGE_NONE][0]['summary'] = text_summary( $body );
            $node->body[LANGUAGE_NONE][0]['format'] = 'full_html';
            break;

        case 'id': // It doesn't make sense that this field would be updated
            $node->field_job_order_id[LANGUAGE_NONE][0]['value'] = $data->id;
            break;

        case 'payRate':
            $node->field_rate[LANGUAGE_NONE][0]['value'] = (string) $data->payRate;
            break;

        case 'dateAdded':
            $alter_time = $data->dateAdded / 1000;
            $post_date = date("Y-m-d", $alter_time);
            $post_date = $post_date . " 00:00:00";
            $node->field_published[LANGUAGE_NONE][0]['value'] = $post_date;
            break;

        case 'dateEnd':
            $alter_time = $data->dateEnd / 1000;
            $post_date = date("Y-m-d", $alter_time);
            $post_date = $post_date . " 00:00:00";
            $node->field_expires[LANGUAGE_NONE][0]['value'] = $post_date;
            break;

        case 'address':
            // Process and attach the job_board_location term for this node
            $country = job_board_process_country_id( $data->address->countryID );
            $field_job_board_location = array();
            $field_job_board_location[] = job_board_process_taxonomy_term( 'job_board_location', $country );
            $field_job_board_location[] = job_board_process_taxonomy_term( 'job_board_location', $data->address->city, $country );

//            $node->field_job_board_location[LANGUAGE_NONE][0] = array( 'tid' => $field_job_board_location[0] );
            $node->field_job_board_location[LANGUAGE_NONE][0] = array( 'tid' => $field_job_board_location[1] );

            // Process and update the country term for this node
            $field_country = job_board_process_taxonomy_term( 'countries', $country );
            $node->field_country[LANGUAGE_NONE][0] = array( 'tid' => $field_country );

            // Process and update the city term for this node
            $field_city = job_board_process_taxonomy_term( 'cities', $data->address->city );
            $node->field_city[LANGUAGE_NONE][0] = array( 'tid' => $field_city );
            break;

        case 'employmentType':
            $field_employment_type = job_board_process_taxonomy_term( 'field_employment_type', $data->employmentType );
            $node->field_employment_type[LANGUAGE_NONE][0] = array( 'tid' => $field_employment_type );
            break;

        case 'categories':
            $field_category = job_board_process_taxonomy_term( 'field_category', $data->categories );
            $node->field_category[LANGUAGE_NONE][0] = array( 'tid' => $field_category );
            break;

        case 'skillList':
            $node->field_skills[LANGUAGE_NONE][0]['value'] = $data->skillList;
            break;
    }

    return $node;
}

/**
 * Bullhorn Job Board Insert
 * 
 * Take a list of JobOrder Entity fields, create
 * properly formatted job_order node and save it
 * to the system
 * 
 * @param $inserts
 */

function bullhorn_job_board_insert( $inserts ) {

//    // If $response is empty then end execution
//    if( empty( $response ) || !$response->count ) {
//        watchdog( 'bullhorn job board', 'Found INSERTED event and the REST request returned no data.', array(), WATCHDOG_DEBUG );
//        return false;
//    }
//
//    // Get the data array
//    $data = $response->data;
//
////    // If $data is empty then end execution
////    if( empty( $data ) ) {
////        return false;
////    }

    // Loop through the $inserts and create job_order nodes
    foreach( $inserts as $insert ) {

        // Take the data for the JobOrder and prepare a node
        // by attaching it to the job_order bundle fields
        $node = bullhorn_job_board_job_order_insert( $insert );
        
        try {
            
            node_save($node);
            watchdog( 'bullhorn job board', 'Found INSERTED event and inserted node title: (%title).', array( '%title' => $node->title ), WATCHDOG_INFO );
            $success = TRUE;
            
        } catch (Exception $e) {
            
            watchdog( 'bullhorn job board', 'Found INSERTED event and failed to save node. Error: ( %exception ), File: ( %file ), Function: ( %function ).', array( '%exception' => $e, '%file' => __FILE__, '%function' => __FUNCTION__ ), WATCHDOG_CRITICAL);
            
        }
    }
}

/**
 * Bullhorn Job Board Update
 *
 * Take a list of JobOrder Entity events and
 * based on the updatedProperties update the
 * affected job_order nodes with the data
 * retrieved from Bullhorn
 *
 * @param $updates
 */

function bullhorn_job_board_update( $updates ) {

    // Loop through the $updates  and update job_order nodes
    foreach( $updates as $update ) {
        // Get the nid which must be a scalar value
        // for node_load()
        $nid          = array_keys( $update['node'] );
        $nid          = array_shift( $nid );

        // Load the node
        $node         = node_load( $nid );

        // Set a new Class for the
        // updated node
        $updated_node = new stdClass();

        // Get the updated data for the updated node
        $data         = $update['updated_data'];

        // Get the properties that will be updated for
        // the node
        $properties   = $update['updated_properties'];

        // Loop through the properties
        // updating and adding them to the
        // $updated node
        foreach( $properties as $property ) {
            $updated_node = bullhorn_job_board_job_order_update( $node, $data, $property );
        }

        try {

            node_save( $updated_node );
            watchdog( 'bullhorn job board', 'Found UPDATED event and updated node title: %title.', array( '%title' => $updated_node->title ), WATCHDOG_INFO );

        } catch( Exception $e ) {
            watchdog( 'bullhorn job board', 'Found UPDATED event and failed to save node ( %nid ).', array( '%nid' => $node->nid ), WATCHDOG_EMERGENCY );

        }
    }

}

function bullhorn_job_board_delete( $deletes ) {

    // Delete the job_order node using the entity_id
    try {

        node_delete_multiple( $deletes['job_order_nids'] );
        $success = true;
        watchdog( 'bullhorn job board', 'Found DELETED event and deleted node(s): %nodes', array( '%nodes' => implode( ',', $deletes['job_order_nids'] ) ), WATCHDOG_NOTICE );

    } catch( Exception $e ) {

        $success = false;
        watchdog( 'bullhorn job board', 'Found DELETED event and failed to delete node(s): ( %nids ).', array( '%nids' => implode( ',', $deletes['job_order_nids'] ) ), WATCHDOG_EMERGENCY );

    }

    // Using the terms attached to the deleted nodes,
    // find any of them attached to any other job_order
    // nodes in the system and if they aren't then delete
    // the term
    if( $success ) {
        job_board_delete_job_order_terms( $deletes['job_order_terms'] );
    }
}

/**
 * Bullhorn Job Board Get Jobs
 */
function bullhorn_job_board_get_jobs () {

    // Set the session
    $session = json_encode( array( ) );
    try {
        $authCode = getAuthCode(); //echo $authCode;die;
        $auth = doBullhornAuth($authCode); //echo $auth;die;
        $tokens = json_decode($auth); //print '<pre>';print_r($tokens);die;
        $session = doBullhornLogin($tokens->access_token);

    } catch (Exception $e) {
        error_log($e->getMessage());
    }

    $session_obj = json_decode($session);

    $job_order = bullhorn_job_board_query($session_obj->BhRestToken, $session_obj->restUrl);

    $job_order_obj = json_decode($job_order);

//$cleanse = str_replace(array("\r\n","\n","\r"),'<br />',$job_order);
    $num = count($job_order_obj->data);
//print '<pre>';
//print_r($job_order_obj->data);
//print_r($num);
    $tax_list = taxonomy_get_vocabularies();

    foreach ($tax_list as $item) {
        if ($item->machine_name == 'job_board_location') {
            $job_board_location_vid = $item->vid;
        }
    }

    require_once 'sites/all/libraries/htmlpurifier/library/HTMLPurifier.auto.php';


    for ($i = 0; $i < $num; $i++) {
        $config = HTMLPurifier_Config::createDefault();
        $config->set('HTML.AllowedElements', 'br,ul,ol,li');
        $config->set('Attr.AllowedClasses', '');
        $config->set('HTML.AllowedAttributes', '');
        $config->set('AutoFormat.RemoveEmpty', true);
        $temp = $job_order_obj->data[$i]->publicDescription;
        $remarks = preg_replace('/<\?xml[^>]+\/>/im', '', $temp);
        $purifier = new HTMLPurifier($config);
        $clean_html = $purifier->purify($remarks);
        $clean_html = nl2br($clean_html);

        $node = new stdClass();
        $node->type = 'job_order';
        node_object_prepare($node);
        $node->title = ucfirst(strtolower($job_order_obj->data[$i]->title));

        $node->language = "en";

        // Attach the body and summary to the node and set the body format to full HTML
        $node->body[LANGUAGE_NONE][0]['value'] = $clean_html;
        $node->body[LANGUAGE_NONE][0]['summary'] = text_summary($clean_html);
        $node->body[LANGUAGE_NONE][0]['format'] = 'full_html';

        // Get the category(ies)
        $full_category = $job_order_obj->data[$i]->categories;

        // Set the Category for this job_order
        if ($full_category->total == 1) {
            // This means this job is associated with a category so we can proceed.
            $category_data = $full_category->data;
            // Now that I got the data, pull out the category ID
            $cat_id = $category_data[0]->id;
        }

        // Set the Category name
        $cat_name = job_board_category_id_to_name($cat_id);

        // Process the Category name and attach it to the node
        $field_category = job_board_process_taxonomy_term('categories',$cat_name);
        $node->field_category[LANGUAGE_NONE][0]['tid'] = $field_category;

        // Attach the JobOrder ID for this node
        $node->field_job_order_id[LANGUAGE_NONE][0]['value'] = $job_order_obj->data[$i]->id;

        // Process and attach the Published date for this node
        $alter_time = $job_order_obj->data[$i]->dateAdded / 1000;
        $post_date = date("Y-m-d", $alter_time);
        $post_date = $post_date . " 00:00:00";
        $node->field_published[LANGUAGE_NONE][0]['value'] = $post_date;

        // Process and attach the Expires data for this node
        $alter_time = $job_order_obj->data[$i]->dateEnd / 1000;
        $post_date = date("Y-m-d", $alter_time);
        $post_date = $post_date . " 00:00:00";
        $node->field_expires[LANGUAGE_NONE][0]['value'] = $post_date;

        // Process and attach the Employment Type to this node
        $employment_type_term = ucwords(strtolower($job_order_obj->data[$i]->employmentType));
        $field_employment_type = job_board_process_taxonomy_term('employment_types',$employment_type_term);
        $node->field_employment_type[LANGUAGE_NONE][0] = array( 'tid' => $field_employment_type );

        // Process the Country and City terms for this node. Associate the City with its applicable Country and attach
        // the City to the node. The View's exposed filter is set to a depth of 1 and will display all Cities for the
        // applicable Country when selected
        $country = job_board_process_country_id( $job_order_obj->data[$i]->address->countryID );
        $field_job_board_location = array();
        $field_job_board_location[] = job_board_process_taxonomy_term( 'job_board_location', $country );
        $field_job_board_location[] = job_board_process_taxonomy_term( 'job_board_location', $job_order_obj->data[$i]->address->city, $country );
//        $node->field_job_board_location[LANGUAGE_NONE][0] = array( 'tid' => $field_job_board_location[0] );
        $node->field_job_board_location[LANGUAGE_NONE][0] = array( 'tid' => $field_job_board_location[1] );


        $field_city = job_board_process_taxonomy_term( 'cities', ucwords( strtolower( $job_order_obj->data[$i]->address->city ) ) );
        $node->field_city[LANGUAGE_NONE][0] = array( 'tid' => $field_city );

        $field_country = job_board_process_taxonomy_term( 'countries' , $country );
        $node->field_country[LANGUAGE_NONE][0] = array( 'tid' => $field_country );

        $skill_list = ucfirst(strtolower($job_order_obj->data[$i]->skillList));

        $skill_list = substr($skill_list, 0, 250);

        $node->field_skills[LANGUAGE_NONE][0]['value'] = $skill_list;

//        $path = 'joborder/programmatically_created_node_' . date('YmdHis');
//        $node->path = array('alias' => $path);
        $node->path['pathauto'] = TRUE;
        $node->uid = 1;
        //print '<pre>';
        //print_r($node);
        //exit();

        try {
            node_save($node);
            $success = TRUE;
            watchdog( 'bullhorn job board', 'Saved job_order. Title: ( %title ).', array( '%title' => $job_order_obj->data[$i]->title ), WATCHDOG_NOTICE );
        } catch (Exception $e) {
            watchdog( 'bullhorn job board', 'Failed to save job_order. Exception: ( %e ), File ( %file ), Function ( %function ).', array( '%e' => $e, '%file' => __FILE__, '%function' => __FUNCTION__), WATCHDOG_EMERGENCY );
        }

        //print_r('Node save was successful.  Nid is '.$node->nid.'<br>');

    }
    // END FOR LOOP

    return '';
}

/**
 * Implementation of hook_form_views_exposed_form_alter()
 *
 * Alter the job-board exposed form and set the default country based on the domain name entry point if that country
 * name term exists
 *
 * @param $form
 * @param $form_state
 */

function bullhorn_job_board_form_views_exposed_form_alter( &$form, &$form_state ) {

    // Select the exposed for that we are looking for, the one on the job-board page
    if( strpos( $form['#id'], 'views-exposed-form-job-board-page' ) !== FALSE ) {

        // Get the domain variables
        $domain = domain_get_domain();

        // Set a list of country names and their associated domain names
        $country_domain = array(
            'Canada'         => 'tundratechnical.ca',
            'United States'  => 'tundratechnical.com',
            'India'          => 'tundratechnical.in',
            'United Kingdom' => 'tundratechnical.co.uk'
        );

         // Set the country by which domain is viewed
        $country_name = array();
        foreach( $country_domain as $d ) {
            if( strpos($domain['subdomain'], $d) !== FALSE ) {
                $country_name = array_keys( $country_domain, $d );
            }
        }

        // Get the country tid
        $country_tid = taxonomy_get_term_by_name( $country_name[0], 'job_board_location') ;
        $tid = array_keys( $country_tid );

        // Continue to set the default country if the country name term exists
        if( !empty( $tid[0] ) && is_numeric( $tid[0] ) ) {
            if( empty( $form_state['view']->exposed_input['term_node_tid_depth'] ) ) {

                $form_state['input']['term_node_tid_depth'] = $tid[0];
            }
        }
    }
}

function bullhorn_rest_form_alter($form, $form_state, $form_id)
{
    if ($form_id == "views_exposed_form" && $form_state['view']->name == "job_board" && $form_state['view']->current_display == "page") {

        $form = NULL;

        //print '<pre>';
        //print_r($form);
        //print '</pre>';

        return $form;

    }
    //return $form;

}

function bullhorn_rest_views_query_alter(&$view, &$query)
{


//simple example: change the order of the master display
    //if you want to do it only  on a certain display add something
    // like  "&&$view->current_display == 'panel_page_1'"
    if ($view->name == "job_board") {
        //print '<pre>';
        //print_r($view->query->fields['field_data_field_city_node_entity_type'] );
        //$view->query->fields['field_data_field_category_node_entity_type'] = NULL;
        //
        $arrayName = array(
            'field' => 'field_data_field_job_board_location.field_job_board_location_tid',
            'value' => '574',
            'operator' => '=');
        //array_push($view->query->where[1]['conditions'], $arrayName);
        //print '<pre>';
        //print_r($view->query->where[1]['conditions'] );
        //print '</pre>';
    }

}



/**
 * Bullhorn Job Board Cron
 */

function bullhorn_job_board_cron() {

    // Run the Bullhorn Job Board Subscribed Events
    bullhorn_job_board_subscribed_events();

}